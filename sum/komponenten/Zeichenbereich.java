package sum.komponenten;import javax.swing.*;import javax.swing.text.*;import javax.swing.event.*;import java.awt.event.*;import java.io.*;import java.lang.reflect.*;import sum.ereignis.*;/**Ein Zeichenbereich ist die zeichenorientierte Unterklasse des Textbereichs. Zeichenbereichesind Editoren mit einer festen Breite und Hoehe. Sie reagieren auf Texteingabenund Mausklicks. Wenn etwas in einen Zeichenbereich getippt werden soll, muss esvorher mit einem Mausklick aktiviert werden, d.h. der Zeichenbereich muss denFokus haben. Der Zeichenbereich ist zeichenorientiert.Fuer zeilenorientierte Bereiche sollte die Klasse Zeilenbereich benutzt werden.@author Bernard Schriek, Horst Hildebrecht@version 7.5 vom 29.10.2013*/public class Zeichenbereich extends Textbereich implements Serializable{	private JTextArea hatTextArea;  	private String zInhaltGeaendertBearbeiter = "";  	private String zMarkierungGeaendertBearbeiter = "";  	public final static String NEUERABSATZ = "\n";		private class DokumentReaktor implements DocumentListener	{		public void insertUpdate(DocumentEvent e)		{			inhaltGeaendert();			markierungGeaendert();		}		public void removeUpdate(DocumentEvent e)		{			inhaltGeaendert();			markierungGeaendert();		}		public void changedUpdate(DocumentEvent e)		{			inhaltGeaendert();			markierungGeaendert();		}	}		private class BereichMausReaktor implements MouseMotionListener	{		public void mouseDragged(MouseEvent e)		{			markierungGeaendert();		}				public void mouseMoved(MouseEvent e)		{}	}		private class BereichFokusReaktor implements FocusListener	{		public void focusGained(FocusEvent e)				{			bekommtFokus();		}				public void focusLost(FocusEvent e)				{			verliertFokus();		}	}/** Der Zeichenbereich wird erzeugt und enthaelt den uebergebenen Text. Position, Breite und Hoehe werden als Parameter uebergeben. Der Zeichenbereich befindet sich auf dem Bildschirm. @param pLinks der Abstand der Komponente vom linken Fensterrand @param pOben der Abstand der Komponente vom oberen Fensterrand @param pBreite die Breite der Komponente @param pHoehe die Hoehe der Komponente @param pText der Inhalt der Komponente*/	public Zeichenbereich(double pLinks, double pOben, double pBreite, double pHoehe, String pText)	{		super(pLinks, pOben, pBreite, pHoehe);		hatTextArea = new JTextArea("", 2, 2);		hatTextArea.setLineWrap(true);		hatTextArea.setWrapStyleWord(true);		hatTextArea.getDocument().addDocumentListener(new DokumentReaktor());		hatTextArea.addMouseMotionListener(new BereichMausReaktor());		hatTextArea.addFocusListener(new BereichFokusReaktor());		this.lerneKomponenteKennen(Bildschirm.topFenster, hatTextArea);		this.init(pLinks, pOben, pBreite, pHoehe, pText);	}	/** Der Zeichenbereich wird erzeugt und enthaelt den uebergebenen Text. Position, Breite und Hoehe werden als Parameter uebergeben. Der Zeichenbereich befindet sich auf dem Fenster. @param pFenster das Fenster, das die Komponente enth&auml;lt @param pLinks der Abstand der Komponente vom linken Fensterrand @param pOben der Abstand der Komponente vom oberen Fensterrand @param pBreite die Breite der Komponente @param pHoehe die Hoehe der Komponente @param pText der Inhalt der Komponente*/	public Zeichenbereich(Fenster pFenster, double pLinks, double pOben, double pBreite, double pHoehe, String pText)	{		super(pLinks, pOben, pBreite, pHoehe);		hatTextArea = new JTextArea("", 2, 2);		hatTextArea.setLineWrap(true);		hatTextArea.setWrapStyleWord(true);		hatTextArea.getDocument().addDocumentListener(new DokumentReaktor());		hatTextArea.addMouseMotionListener(new BereichMausReaktor());		hatTextArea.addFocusListener(new BereichFokusReaktor());		this.lerneKomponenteKennen(pFenster, hatTextArea);		this.init(pLinks, pOben, pBreite, pHoehe, pText);	}	/** Der Zeichenbereich reagiert auf Veraenderungen.*/	protected void inhaltGeaendert()	{		Class sumEreignis;		Class[] formparas = new Class[1];		Method methode;		Zeichenbereich[] meinZeichenbereich = new Zeichenbereich[1];				if (zInhaltGeaendertBearbeiter.length() > 0)		{			try			{				sumEreignis = Ereignisanwendung.hatSuMPrivateAnwendung.getClass();				try				{					methode = sumEreignis.getDeclaredMethod(zInhaltGeaendertBearbeiter, null);					methode.setAccessible(true);					methode.invoke(Ereignisanwendung.hatSuMPrivateAnwendung, null);							}				catch (InvocationTargetException e0)				{					System.out.println("Fehler in Methode \"" + zInhaltGeaendertBearbeiter + "\" eines Zeichenbereichs: " + e0.getTargetException().toString());					e0.printStackTrace();				}				catch (Exception e1)				{					try					{						formparas[0] = Zeichenbereich.class;						methode = sumEreignis.getDeclaredMethod(zInhaltGeaendertBearbeiter, formparas);						methode.setAccessible(true);						meinZeichenbereich[0] = this;						methode.invoke(Ereignisanwendung.hatSuMPrivateAnwendung, meinZeichenbereich);								}					catch (InvocationTargetException e2)					{						System.out.println("Fehler in Methode \"" + zInhaltGeaendertBearbeiter + "\" eines Zeichenbereichs: " + e2.getTargetException().toString());						e2.printStackTrace();					}					catch (Exception e3)					{						System.out.println("Fehler: Methode \"" + zInhaltGeaendertBearbeiter + "\" eines Zeichenbereichs nicht gefunden.");					}				}			}			catch (Exception e4)			{				System.out.println("SuMAnwendung: " + e4.toString());			}		}	}	/** Der Zeichenbereich reagiert auf Veraenderungen der Markierung.*/	protected void markierungGeaendert()	{		Class sumEreignis;		Class[] formparas = new Class[1];		Method methode;		Zeichenbereich[] meinZeichenbereich = new Zeichenbereich[1];				if (zMarkierungGeaendertBearbeiter.length() > 0)		{			try			{				sumEreignis = Ereignisanwendung.hatSuMPrivateAnwendung.getClass();				try				{					methode = sumEreignis.getDeclaredMethod(zMarkierungGeaendertBearbeiter, null);					methode.setAccessible(true);					methode.invoke(Ereignisanwendung.hatSuMPrivateAnwendung, null);							}				catch (InvocationTargetException e0)				{					System.out.println("Fehler in Methode \"" + zMarkierungGeaendertBearbeiter + "\" eines Zeichenbereichs: " + e0.getTargetException().toString());					e0.printStackTrace();				}				catch (Exception e1)				{					try					{						formparas[0] = Zeichenbereich.class;						methode = sumEreignis.getDeclaredMethod(zMarkierungGeaendertBearbeiter, formparas);						methode.setAccessible(true);						meinZeichenbereich[0] = this;						methode.invoke(Ereignisanwendung.hatSuMPrivateAnwendung, meinZeichenbereich);								}					catch (InvocationTargetException e2)					{						System.out.println("Fehler in Methode \"" + zMarkierungGeaendertBearbeiter + "\" eines Zeichenbereichs: " + e2.getTargetException().toString());						e2.printStackTrace();					}					catch (Exception e3)					{						System.out.println("Fehler: Methode \"" + zMarkierungGeaendertBearbeiter + "\" eines Zeichenbereichs nicht gefunden.");					}				}			}			catch (Exception e4)			{				System.out.println("SuMAnwendung: " + e4.toString());			}		}	}	/** Der Zeichenbereich erhaelt den Fokus.*/	protected void bekommtFokus()	{		Class sumEreignis;		Class[] formparas = new Class[1];		Method methode;		Zeichenbereich[] meinZeichenbereich = new Zeichenbereich[1];				this.setzeFokusWert(true);		if (this.fokusErhaltenBearbeiter().length() > 0)		{			try			{				sumEreignis = Ereignisanwendung.hatSuMPrivateAnwendung.getClass();				try				{					methode = sumEreignis.getDeclaredMethod(this.fokusErhaltenBearbeiter(), null);					methode.setAccessible(true);					methode.invoke(Ereignisanwendung.hatSuMPrivateAnwendung, null);							}				catch (InvocationTargetException e0)				{					System.out.println("Fehler in Methode \"" + this.fokusErhaltenBearbeiter() + "\" eines Zeichenbereichs: " + e0.getTargetException().toString());					e0.printStackTrace();				}				catch (Exception e1)				{					try					{						formparas[0] = Zeichenbereich.class;						methode = sumEreignis.getDeclaredMethod(this.fokusErhaltenBearbeiter(), formparas);						methode.setAccessible(true);						meinZeichenbereich[0] = this;						methode.invoke(Ereignisanwendung.hatSuMPrivateAnwendung, meinZeichenbereich);								}					catch (InvocationTargetException e2)					{						System.out.println("Fehler in Methode \"" + this.fokusErhaltenBearbeiter() + "\" eines Zeichenbereichs: " + e2.getTargetException().toString());						e2.printStackTrace();					}					catch (Exception e3)					{						System.out.println("Fehler: Methode \"" + this.fokusErhaltenBearbeiter() + "\" eines Zeichenbereichs nicht gefunden.");					}				}			}			catch (Exception e4)			{				System.out.println("SuMAnwendung: " + e4.toString());			}		}	}	/** Der Zeichenbereich verliert den Fokus.*/	protected void verliertFokus()	{		Class sumEreignis;		Class[] formparas = new Class[1];		Method methode;		Zeichenbereich[] meinZeichenbereich = new Zeichenbereich[1];				this.setzeFokusWert(false);		if (this.fokusVerlorenBearbeiter().length() > 0)		{			try			{				sumEreignis = Ereignisanwendung.hatSuMPrivateAnwendung.getClass();				try				{					methode = sumEreignis.getDeclaredMethod(this.fokusVerlorenBearbeiter(), null);					methode.setAccessible(true);					methode.invoke(Ereignisanwendung.hatSuMPrivateAnwendung, null);							}				catch (InvocationTargetException e0)				{					System.out.println("Fehler in Methode \"" + this.fokusVerlorenBearbeiter() + "\" eines Zeichenbereichs: " + e0.getTargetException().toString());					e0.printStackTrace();				}				catch (Exception e1)				{					try					{						formparas[0] = Zeichenbereich.class;						methode = sumEreignis.getDeclaredMethod(this.fokusVerlorenBearbeiter(), formparas);						methode.setAccessible(true);						meinZeichenbereich[0] = this;						methode.invoke(Ereignisanwendung.hatSuMPrivateAnwendung, meinZeichenbereich);								}					catch (InvocationTargetException e2)					{						System.out.println("Fehler in Methode \"" + this.fokusVerlorenBearbeiter() + "\" eines Zeichenbereichs: " + e2.getTargetException().toString());						e2.printStackTrace();					}					catch (Exception e3)					{						System.out.println("Fehler: Methode \"" + this.fokusVerlorenBearbeiter() + "\" eines Zeichenbereichs nicht gefunden.");					}				}			}			catch (Exception e4)			{				System.out.println("SuMAnwendung: " + e4.toString());			}		}	}	/** Der Dienst zur Bearbeitung des InhaltGeaendert-Ereignisses in @param pBearbeiter der Bezeichner des Dienstes der SuMAnwendung, der aufgerufen wird, wenn der Inhalt der Komponente geaendert wurde. der Ereignisanwendung wird festgelegt.*/	public void setzeBearbeiterInhaltGeaendert(String pBearbeiter)	{		zInhaltGeaendertBearbeiter = pBearbeiter;	}	/** Der Dienst zur Bearbeitung des MarkierungGeaendert-Ereignisses in der Ereignisanwendung wird festgelegt. @param pBearbeiter der Bezeichner des Dienstes der SuMAnwendung, der aufgerufen wird, wenn die Markierung der Komponente geaendert wurde.*/	public void setzeBearbeiterMarkierungGeaendert(String pBearbeiter)	{		zMarkierungGeaendertBearbeiter = pBearbeiter;	}	/** Die Anzahl der Zeichen im Zeichenbereich wird zurueckgegeben. @return die Anzahl der Zeichen der Komponente*/	public int anzahl()	{		return hatTextArea.getText().length();	}	/** Ein neuer Absatz wird erzeugt.*/	public void neuerAbsatz()	{		hatTextArea.append("" + NEUERABSATZ);		hatTextArea.paintImmediately(0, 0, hatTextArea.getWidth(), hatTextArea.getHeight());	}		/** Der Text pText wird an Position pStelle eingefuegt. @param pText der Text, der eingefuegt wird @param pStelle die Stelle, wo der Text eingefuegt wird*/	public void fuegeEin(String pText, int pStelle)	{		hatTextArea.insert(pText, pStelle - 1);		hatTextArea.paintImmediately(0, 0, hatTextArea.getWidth(), hatTextArea.getHeight());	}	/** Der Text pText wird am Ende angehaengt. @param pText der Text, der ans Ende angehaengt wird*/	public void haengeAn(String pText)	{		hatTextArea.append(pText);		hatTextArea.paintImmediately(0, 0, hatTextArea.getWidth(), hatTextArea.getHeight());	}	/** Das Zeichen pZeichen wird ans Ende angehaengt. @param pZeichen das Zeichen, das ans Ende angehaengt wird*/	public void haengeAn(char pZeichen)	{		hatTextArea.append("" + pZeichen);		hatTextArea.paintImmediately(0, 0, hatTextArea.getWidth(), hatTextArea.getHeight());	}	/** Das ganze Zahl pZahl wird am Ende angehaengt. @param pZahl die Zahl, die ans Ende angehaengt wird*/	public void haengeAn(int pZahl)	{		hatTextArea.append("" + pZahl);		hatTextArea.paintImmediately(0, 0, hatTextArea.getWidth(), hatTextArea.getHeight());	}	/** Das Kommazahl pZahl wird am Ende angehaengt. @param pZahl die Zahl, die ans Ende angehaengt wird*/	public void haengeAn(double pZahl)	{		hatTextArea.append("" + pZahl);		hatTextArea.paintImmediately(0, 0, hatTextArea.getWidth(), hatTextArea.getHeight());	}	/** Der Zeichenbereich erhaelt einen neuen Inhalt. @param pText der Text, der als neuer Inhalt gesetzt wird*/	public void setzeInhalt(String pText)	{		hatTextArea.setText(pText);		hatTextArea.paintImmediately(0, 0, hatTextArea.getWidth(), hatTextArea.getHeight());	}	/**Der Text der Zeichenbereich wird als String zurueckgegeben.@return der Inhalt der Komponente als Zeichenkette (String)*/	public String inhaltAlsText()	{		return hatTextArea.getText();	}		/**Der Inhalt des Zeichenbereichs von pAnfang bis pEnde wird als String zurueckgegeben.@param pAnfang erste Zeichenposition@param pEnde letzte Zeichenposition@return der Inhalt in den gewaehlten Zeilen der Komponente als Zeichenkette (String)*/	public String teilinhalt(int pAnfang, int pEnde)	{		String s;				s = hatTextArea.getText();		return s.substring(pAnfang - 1, pEnde);	}	/** Der im Textfeld markierte Text wird geliefert. @return der markierte Text*/	public String markierterInhalt()	{		return hatTextArea.getSelectedText();	}	/** Der Text zwischen den Zeichen an Position pAnfang und pEnde wird markiert.@param pAnfang erste Zeichenposition@param pEnde letzte Zeichenposition*/	public void setzeMarkierung(int pAnfang, int pEnde)	{		hatTextArea.requestFocus();		hatTextArea.select(pAnfang-1, pEnde);		this.markierungGeaendert();	}	/** Der gesamte Text wird markiert.*/	public void markiereAlles()	{		hatTextArea.requestFocus();		hatTextArea.selectAll();		this.markierungGeaendert();	}	/** Der gesamte Text wird nicht markiert.*/	public void markiereNichts()	{		hatTextArea.requestFocus();		hatTextArea.select(0, 0);		this.markierungGeaendert();	}	/** Der gesamte Text wird geloescht.*/	public void loescheAlles()	{		this.setzeInhalt("");	}	/** Der markierte Text wird geloescht.*/	public void loescheMarkierung()	{		String s, s1, s2;		int von, bis;				s = hatTextArea.getText();		von = hatTextArea.getSelectionStart();		bis = hatTextArea.getSelectionEnd();		if (bis > von)		{			s1 = s.substring(0, von);			s2 = s.substring(bis, s.length());			this.setzeInhalt(s1 + s2);			this.markierungGeaendert();		}			}	/**Der durch die Parameter bestimmte Text wird geloescht.@param pAnfang erste Zeichenposition@param pEnde letzte Zeichenposition*/	public void loesche(int pAnfang, int pEnde)	{		String s, s1, s2;				s = hatTextArea.getText();		s1 = s.substring(0, pAnfang - 1);		s2 = s.substring(pEnde, s.length());		this.setzeInhalt(s1 + s2);		this.markierungGeaendert();	}	/** Es wird zurueckgegeben, ob der Text markiert ist. @return true, wenn Text markiert ist*/	public boolean istMarkiert()	{		return hatTextArea.getSelectionStart() < hatTextArea.getSelectionEnd();	}	/**Es wird zurueckgegeben, von wo an der Text markiert ist.@return die erste markierte Position*/	public int markierungsAnfang()	{		return hatTextArea.getSelectionStart()+1;	}	/**Es wird zurueckgegeben, bis wohin der Text markiert ist.@return die letzte markierte Position*/	public int markierungsEnde()	{		return hatTextArea.getSelectionEnd();	}}