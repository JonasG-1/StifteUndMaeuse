package sum.komponenten;import javax.swing.*;import javax.swing.text.*;import javax.swing.event.*;import java.awt.event.*;import java.io.*;import java.lang.reflect.*;import sum.ereignis.*;/**Ein Zeilenbereich ist die zeilenorientierte Unterklasse des Textbereichs. Zeilenbereiche sind zeilenorientierte Editoren mit einer festen Breite und Hoehe. Sie reagieren auf Texteingaben und Mausklicks. Wenn etwas in einen Zeilenbereich getippt werden soll,muss er vorher mit einem Mausklick aktiviert werden, d.h. der Zeilenbereich muss denFokus haben. Der Zeilenbereich ist zeilenorientiert. Fuer zeichenorientierte Bereiche solltedie Klasse Zeichenbereich benutzt werden.@author Bernard Schriek, Horst Hildebrecht@version 7.5 vom 29.10.2013*/public class Zeilenbereich extends Textbereich implements Serializable{	private JTextArea hatTextArea;  	private String zInhaltGeaendertBearbeiter = "";  	private String zMarkierungGeaendertBearbeiter = "";  	public final static String NEUERABSATZ = "\n";		private class DokumentReaktor implements DocumentListener	{		public void insertUpdate(DocumentEvent e)		{			inhaltGeaendert();			markierungGeaendert();		}		public void removeUpdate(DocumentEvent e)		{			inhaltGeaendert();			markierungGeaendert();		}		public void changedUpdate(DocumentEvent e)		{			inhaltGeaendert();			markierungGeaendert();		}	}		private class BereichMausReaktor implements MouseMotionListener	{		public void mouseDragged(MouseEvent e)		{			markierungGeaendert();		}				public void mouseMoved(MouseEvent e)		{}	}		private class BereichFokusReaktor implements FocusListener	{		public void focusGained(FocusEvent e)				{			bekommtFokus();		}				public void focusLost(FocusEvent e)				{			verliertFokus();		}	}/** Der Zeilenbereich wird erzeugt und enthaelt den uebergebenen Text. Position, Breite und Hoehe werden als Parameter uebergeben. Der Zeilenbereich befindet sich auf dem Bildschirm. @param pLinks der Abstand der Komponente vom linken Fensterrand @param pOben der Abstand der Komponente vom oberen Fensterrand @param pBreite die Breite der Komponente @param pHoehe die Hoehe der Komponente @param pText der Inhalt der Komponente*/	public Zeilenbereich(double pLinks, double pOben, double pBreite, double pHoehe, String pText)	{		super(pLinks, pOben, pBreite, pHoehe);		hatScrollPane.setHorizontalScrollBarPolicy(ScrollPaneConstants.HORIZONTAL_SCROLLBAR_AS_NEEDED);		hatTextArea = new JTextArea("", 2, 2);		hatTextArea.setLineWrap(false);		hatTextArea.getDocument().addDocumentListener(new DokumentReaktor());		hatTextArea.addMouseMotionListener(new BereichMausReaktor());		hatTextArea.addFocusListener(new BereichFokusReaktor());		this.lerneKomponenteKennen(Bildschirm.topFenster, hatTextArea);		this.init(pLinks, pOben, pBreite, pHoehe, pText);	}	/** Der Zeilenbereich wird erzeugt und enthaelt den uebergebenen Text. Position, Breite und Hoehe werden als Parameter uebergeben. Der Zeilenbereich befindet sich auf dem Fenster. @param pFenster das Fenster, das die Komponente enth&auml;lt @param pLinks der Abstand der Komponente vom linken Fensterrand @param pOben der Abstand der Komponente vom oberen Fensterrand @param pBreite die Breite der Komponente @param pHoehe die Hoehe der Komponente @param pText der Inhalt der Komponente*/	public Zeilenbereich(Fenster pFenster, double pLinks, double pOben, double pBreite, double pHoehe, String pText)	{		super(pFenster, pLinks, pOben, pBreite, pHoehe);		hatScrollPane.setHorizontalScrollBarPolicy(ScrollPaneConstants.HORIZONTAL_SCROLLBAR_AS_NEEDED);		hatTextArea = new JTextArea("", 2, 2);		hatTextArea.setLineWrap(false);		hatTextArea.getDocument().addDocumentListener(new DokumentReaktor());		hatTextArea.addMouseMotionListener(new BereichMausReaktor());		hatTextArea.addFocusListener(new BereichFokusReaktor());		this.lerneKomponenteKennen(pFenster, hatTextArea);		this.init(pLinks, pOben, pBreite, pHoehe, pText);	}	/** Der Zeilenbereich reagiert auf Veraenderungen.*/	protected void inhaltGeaendert()	{		Class sumEreignis;		Class[] formparas = new Class[1];		Method methode;		Zeilenbereich[] meinZeilenbereich = new Zeilenbereich[1];				if (zInhaltGeaendertBearbeiter.length() > 0)		{			try			{				sumEreignis = Ereignisanwendung.hatSuMPrivateAnwendung.getClass();				try				{					methode = sumEreignis.getDeclaredMethod(zInhaltGeaendertBearbeiter, null);					methode.setAccessible(true);					methode.invoke(Ereignisanwendung.hatSuMPrivateAnwendung, null);							}				catch (InvocationTargetException e0)				{					System.out.println("Fehler in Methode \"" + zInhaltGeaendertBearbeiter + "\" eines Zeilenbereichs: " + e0.getTargetException().toString());					e0.printStackTrace();				}				catch (Exception e1)				{					try					{						formparas[0] = Zeilenbereich.class;						methode = sumEreignis.getDeclaredMethod(zInhaltGeaendertBearbeiter, formparas);						methode.setAccessible(true);						meinZeilenbereich[0] = this;						methode.invoke(Ereignisanwendung.hatSuMPrivateAnwendung, meinZeilenbereich);								}					catch (InvocationTargetException e2)					{						System.out.println("Fehler in Methode \"" + zInhaltGeaendertBearbeiter + "\" eines Zeilenbereichs: " + e2.getTargetException().toString());						e2.printStackTrace();					}					catch (Exception e3)					{						System.out.println("Fehler: Methode \"" + zInhaltGeaendertBearbeiter + "\" eines Zeilenbereichs nicht gefunden.");					}				}			}			catch (Exception e4)			{				System.out.println("SuMAnwendung: " + e4.toString());			}		}	}	/** Der Zeilenbereich reagiert auf Veraenderungen der Markierung.*/	protected void markierungGeaendert()	{		Class sumEreignis;		Class[] formparas = new Class[1];		Method methode;		Zeilenbereich[] meinZeilenbereich = new Zeilenbereich[1];				if (zMarkierungGeaendertBearbeiter.length() > 0)		{			try			{				sumEreignis = Ereignisanwendung.hatSuMPrivateAnwendung.getClass();				try				{					methode = sumEreignis.getDeclaredMethod(zMarkierungGeaendertBearbeiter, null);					methode.setAccessible(true);					methode.invoke(Ereignisanwendung.hatSuMPrivateAnwendung, null);							}				catch (InvocationTargetException e0)				{					System.out.println("Fehler in Methode \"" + zMarkierungGeaendertBearbeiter + "\" eines Zeilenbereichs: " + e0.getTargetException().toString());					e0.printStackTrace();				}				catch (Exception e1)				{					try					{						formparas[0] = Zeilenbereich.class;						methode = sumEreignis.getDeclaredMethod(zMarkierungGeaendertBearbeiter, formparas);						methode.setAccessible(true);						meinZeilenbereich[0] = this;						methode.invoke(Ereignisanwendung.hatSuMPrivateAnwendung, meinZeilenbereich);								}					catch (InvocationTargetException e2)					{						System.out.println("Fehler in Methode \"" + zMarkierungGeaendertBearbeiter + "\" eines Zeilenbereichs: " + e2.getTargetException().toString());						e2.printStackTrace();					}					catch (Exception e3)					{						System.out.println("Fehler: Methode \"" + zMarkierungGeaendertBearbeiter + "\" eines Zeilenbereichs nicht gefunden.");					}				}			}			catch (Exception e4)			{				System.out.println("SuMAnwendung: " + e4.toString());			}		}	}	/** Der Zeilenbereich erhaelt den Fokus.*/	protected void bekommtFokus()	{		Class sumEreignis;		Class[] formparas = new Class[1];		Method methode;		Zeilenbereich[] meinZeilenbereich = new Zeilenbereich[1];				this.setzeFokusWert(true);		if (this.fokusErhaltenBearbeiter().length() > 0)		{			try			{				sumEreignis = Ereignisanwendung.hatSuMPrivateAnwendung.getClass();				try				{					methode = sumEreignis.getDeclaredMethod(this.fokusErhaltenBearbeiter(), null);					methode.setAccessible(true);					methode.invoke(Ereignisanwendung.hatSuMPrivateAnwendung, null);							}				catch (InvocationTargetException e0)				{					System.out.println("Fehler in Methode \"" + this.fokusErhaltenBearbeiter() + "\" eines Zeilenbereichs: " + e0.getTargetException().toString());					e0.printStackTrace();				}				catch (Exception e1)				{					try					{						formparas[0] = Zeilenbereich.class;						methode = sumEreignis.getDeclaredMethod(this.fokusErhaltenBearbeiter(), formparas);						methode.setAccessible(true);						meinZeilenbereich[0] = this;						methode.invoke(Ereignisanwendung.hatSuMPrivateAnwendung, meinZeilenbereich);								}					catch (InvocationTargetException e2)					{						System.out.println("Fehler in Methode \"" + this.fokusErhaltenBearbeiter() + "\" eines Zeilenbereichs: " + e2.getTargetException().toString());						e2.printStackTrace();					}					catch (Exception e3)					{						System.out.println("Fehler: Methode \"" + this.fokusErhaltenBearbeiter() + "\" eines Zeilenbereichs nicht gefunden.");					}				}			}			catch (Exception e4)			{				System.out.println("SuMAnwendung: " + e4.toString());			}		}	}	/** Der Zeilenbereich verliert den Fokus.*/	protected void verliertFokus()	{		Class sumEreignis;		Class[] formparas = new Class[1];		Method methode;		Zeilenbereich[] meinZeilenbereich = new Zeilenbereich[1];				this.setzeFokusWert(false);		if (this.fokusVerlorenBearbeiter().length() > 0)		{			try			{				sumEreignis = Ereignisanwendung.hatSuMPrivateAnwendung.getClass();				try				{					methode = sumEreignis.getDeclaredMethod(this.fokusVerlorenBearbeiter(), null);					methode.setAccessible(true);					methode.invoke(Ereignisanwendung.hatSuMPrivateAnwendung, null);							}				catch (InvocationTargetException e0)				{					System.out.println("Fehler in Methode \"" + this.fokusVerlorenBearbeiter() + "\" eines Zeilenbereichs: " + e0.getTargetException().toString());					e0.printStackTrace();				}				catch (Exception e1)				{					try					{						formparas[0] = Zeilenbereich.class;						methode = sumEreignis.getDeclaredMethod(this.fokusVerlorenBearbeiter(), formparas);						methode.setAccessible(true);						meinZeilenbereich[0] = this;						methode.invoke(Ereignisanwendung.hatSuMPrivateAnwendung, meinZeilenbereich);								}					catch (InvocationTargetException e2)					{						System.out.println("Fehler in Methode \"" + this.fokusVerlorenBearbeiter() + "\" eines Zeilenbereichs: " + e2.getTargetException().toString());						e2.printStackTrace();					}					catch (Exception e3)					{						System.out.println("Fehler: Methode \"" + this.fokusVerlorenBearbeiter() + "\" eines Zeilenbereichs nicht gefunden.");					}				}			}			catch (Exception e4)			{				System.out.println("SuMAnwendung: " + e4.toString());			}		}	}	/** Die Methode zur Bearbeitung des InhaltGeaendert-Ereignisses in der Ereignisanwendung wird festgelegt. @param pBearbeiter der Bezeichner des Dienstes der SuMAnwendung, der aufgerufen wird, wenn der Inhalt der Komponente geaendert wurde.*/	public void setzeBearbeiterInhaltGeaendert(String pBearbeiter)	{		zInhaltGeaendertBearbeiter = pBearbeiter;	}	/** Die Methode zur Bearbeitung des MarkierungGeaendert-Ereignisses in der Ereignisanwendung wird festgelegt. @param pBearbeiter der Bezeichner des Dienstes der SuMAnwendung, der aufgerufen wird, wenn die Markierung der Komponente geaendert wurde.*/	public void setzeBearbeiterMarkierungGeaendert(String pBearbeiter)	{		zMarkierungGeaendertBearbeiter = pBearbeiter;	}	/** Die Anzahl der Zeilen im Zeilenbereich wird zurueckgegeben. @return die Anzahl der Zeilen der Komponente*/	public int anzahl()	{		return hatTextArea.getLineCount();	}	/** Ein neuer Absatz wird erzeugt.*/	public void neuerAbsatz()	{		hatTextArea.append("" + NEUERABSATZ);		hatTextArea.paintImmediately(0, 0, hatTextArea.getWidth(), hatTextArea.getHeight());	}		/** Der Text pText wird als Zeile pZeile eingefuegt. @param pText der Text, der eingefuegt wird @param pZeile die Zeilennummer, wo der Text als neue Zeile eingefuegt wird*/	public void fuegeEin(String pText, int pZeile)	{		try		{			hatTextArea.insert(pText + '\n', hatTextArea.getLineStartOffset(pZeile - 1));		}		catch (Exception e)		{			System.out.println(e.toString());		}		hatTextArea.paintImmediately(0, 0, hatTextArea.getWidth(), hatTextArea.getHeight());	}	/** Der Text pText wird als neue Zeile am Ende angehaengt. @param pText der Text, der als neue Zeile angehaengt wird*/	public void haengeAn(String pText)	{		hatTextArea.append(pText + '\n');		hatTextArea.paintImmediately(0, 0, hatTextArea.getWidth(), hatTextArea.getHeight());	}	/** Das Zeichen pZeichen wird als neue Zeile am Ende angehaengt. @param pZeichen das Zeichen, das als neue Zeile angehaengt wird*/	public void haengeAn(char pZeichen)	{		this.haengeAn("" + pZeichen);	}	/** Das ganze Zahl pZahl wird als neue Zeile am Ende angehaengt. @param pZahl die Zahl, die als neue Zeile angehaengt wird*/	public void haengeAn(int pZahl)	{		this.haengeAn("" + pZahl);	}	/** Das Kommazahl pZahl wird als neue Zeile am Ende angehaengt. @param pZahl die Zahl, die als neue Zeile angehaengt wird*/	public void haengeAn(double pZahl)	{		this.haengeAn("" + pZahl);	}	/** Der Zeilenbereich erhaelt einen neuen Inhalt. @param pText der Text, der als neuer Inhalt gesetzt wird*/	public void setzeInhalt(String pText)	{		hatTextArea.setText(pText);		hatTextArea.paintImmediately(0, 0, hatTextArea.getWidth(), hatTextArea.getHeight());	}	/**Der Text des Zeilenbereichs wird als String zurueckgegeben.@return der Inhalt der Komponente als Zeichenkette (String)*/	public String inhaltAlsText()	{		return hatTextArea.getText();	}		/**Der Inhalt des Zeilenbereichs von Zeile pAnfang bis Zeile pEnde wird als String zurueckgegeben.Die Zeilennummerierung beginnt bei 1.@param pAnfang erste Zeile@param pEnde letzte Zeile@return der Inhalt in den gewaehlten Zeilen der Komponente als Zeichenkette (String)*/	public String teilinhalt(int pAnfang, int pEnde)	{		try		{			if (hatTextArea.getLineStartOffset(pAnfang - 1) == hatTextArea.getLineEndOffset(pEnde - 1))				return "";			else				if (pEnde < this.anzahl())					return hatTextArea.getText(hatTextArea.getLineStartOffset(pAnfang - 1), 						hatTextArea.getLineEndOffset(pEnde - 1) - hatTextArea.getLineStartOffset(pAnfang - 1) - 1);				else					return hatTextArea.getText(hatTextArea.getLineStartOffset(pAnfang - 1), 						hatTextArea.getLineEndOffset(pEnde - 1) - hatTextArea.getLineStartOffset(pAnfang - 1));		}		catch (Exception e)		{			System.out.println(e.toString());			return null;		}	}	/** Der im Zeilenbereich markierte Text wird geliefert. @return der markierte Text*/	public String markierterInhalt()	{		return hatTextArea.getSelectedText();	}	/**Der Text zwischen den Zeilen pAnfang und pEndewird markiert.Die Zeilennummerierung beginnt bei 1.@param pAnfang erste Zeile@param pEnde letzte Zeile*/	public void setzeMarkierung(int pAnfang, int pEnde)	{		try		{			hatTextArea.requestFocus();			hatTextArea.select(hatTextArea.getLineStartOffset(pAnfang - 1), hatTextArea.getLineEndOffset(pEnde - 1));			this.markierungGeaendert();		}		catch (Exception e)		{			System.out.println(e.toString());		}	}/** Der gesamte Text wird markiert.*/	public void markiereAlles()	{		hatTextArea.requestFocus();		hatTextArea.selectAll();		hatTextArea.paintImmediately(0, 0, hatTextArea.getWidth(), hatTextArea.getHeight());		this.markierungGeaendert();	}	/** Der gesamte Text wird nicht markiert.*/	public void markiereNichts()	{		hatTextArea.requestFocus();		hatTextArea.select(0, 0);		hatTextArea.paintImmediately(0, 0, hatTextArea.getWidth(), hatTextArea.getHeight());		this.markierungGeaendert();	}	/** Der gesamte Text wird geloescht.*/	public void loescheAlles()	{		this.setzeInhalt("");	}	/** Der markierte Text wird geloescht.*/	public void loescheMarkierung()	{		hatTextArea.cut();		hatTextArea.paintImmediately(0, 0, hatTextArea.getWidth(), hatTextArea.getHeight()); 	}	/**Der durch die Parameter bestimmte Text wird geloescht.Die Zeilennummerierung beginnt bei 1.@param pAnfang erste Zeile@param pEnde letzte Zeile*/	public void loesche(int pAnfang, int pEnde)	{		this.setzeMarkierung(pAnfang, pEnde);		this.loescheMarkierung();	}	/** Es wird zurueckgegeben, ob Text markiert ist. @return true, wenn Text markiert ist*/	public boolean istMarkiert()	{		return hatTextArea.getSelectionStart() < hatTextArea.getSelectionEnd();	}	/**Es wird zurueckgegeben, von welcher Zeile an der Text markiert ist.Die Zeilennummerierung beginnt bei 1.@return die erste markierte Zeile*/	public int markierungsAnfang()	{		try		{			return hatTextArea.getLineOfOffset(hatTextArea.getSelectionStart()) + 1;		}		catch (Exception e)		{			System.out.println(e.toString());			return 0;		}	}	/**Es wird zurueckgegeben, bis zu welcher Zeile der Text markiert ist.Die Zeilennummerierung beginnt bei 1.@return die letzte markierte Zeile*/	public int markierungsEnde()	{		try		{			return hatTextArea.getLineOfOffset(hatTextArea.getSelectionEnd()) + 1;		}		catch (Exception e)		{			System.out.println(e.toString());			return 0;		}	}}