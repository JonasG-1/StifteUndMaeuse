package sum.netz;import java.io.*;import java.net.*;/**Eine Verbindung ist ein Socket, der eine vereinfachte Ein- und Ausgabe bietet.<br>Fehlermeldungen werden ausgegeben.<br>Auf Wunsch wird jeder Schritt mitprotokolliert.<br>Die Verbindung ist nicht nebenl&auml;ufig realisiert.<br>Da sie eine Unterklasse von Thread ist, k&ouml;nnen Unterklassen der Verbindung nebenl&auml;ufig arbeiten.@author Horst Hildebrecht@version 7.5 vom 29.10.2013*/public class Verbindung extends Thread implements Serializable{	//Objektbeziehungen	private Socket hatSocket; // Besser w&auml;re eine Unterklasse. Wegen des n&ouml;tigen super-Aufrufs in try nicht m&ouml;glich!	private BufferedReader hatEingabe;	private PrintStream hatAusgabe;		// Attribute	private boolean zMitNachrichten;	private int zPartnerPort, zEigenerPort;	private String zPartnerAdresse, zEigeneAdresse;	protected boolean zVerbindungAktiv; // Nur f&uuml;r Unterklassen, die echte Threads sind (ServerVerbindung)	/**	Nur aus technischen Gr&uuml;nden enthaltener Konstruktor.	*/	protected Verbindung()	{}		/**	Die Verbindung ist mit Ein- und Ausgabestreams initialisiert.	@param pSocket Socket, der die Verbindung beschreibt	@param pTestModus Wenn true, werden bei jeder Operation Meldungen auf der Konsole ausgegeben.	*/	public Verbindung(Socket pSocket, boolean pTestModus)	{ 	 	this.erstelleVerbindung(pSocket, pTestModus);	} 		/**	Die Verbindung ist mit Ein- und Ausgabestreams initialisiert.	@param pIPAdresse IP-Adresse bzw. Domain des Partners	@param pPortNr Portnummer des Sockets	@param pTestModus Wenn true, werden bei jeder Operation Meldungen auf der Konsole ausgegeben.	*/	public Verbindung(String pIPAdresse, int pPortNr, boolean pTestModus)	{		try	 	{ 			this.erstelleVerbindung(new Socket(pIPAdresse, pPortNr), pTestModus); 		} 		 		catch (Exception fehler)	 	{	 		hatSocket = null;	 		System.err.println("Fehler beim \u00D6ffnen von Socket: " + fehler);	 	}	 		}		/**	Die Verbindung ist mit Ein- und Ausgabestreams initialisiert.	@param pSocket Socket, der die Verbindung beschreibt	@param pTestModus Wenn true, werden bei jeder Operation Meldungen auf der Konsole ausgegeben.	*/	protected void erstelleVerbindung(Socket pSocket, boolean pTestModus) 	{ 		hatSocket = pSocket; 	 	zMitNachrichten = pTestModus;		zVerbindungAktiv = true;		zPartnerAdresse = this.verbindungsSocket().getInetAddress().toString();		//System.out.println("Partner vorher: <" + zPartnerAdresse + ">");		zPartnerAdresse = zPartnerAdresse.substring(zPartnerAdresse.indexOf('/') + 1);		//System.out.println("Partner nachher: <" + zPartnerAdresse + ">");		zPartnerPort = this.verbindungsSocket().getPort();		zEigeneAdresse = this.verbindungsSocket().getLocalAddress().toString();		//System.out.println("Eigene vorher: <" + zEigeneAdresse + ">");		zEigeneAdresse = zEigeneAdresse.substring(zEigeneAdresse.indexOf('/') + 1);		//System.out.println("Eigene nachher: <" + zEigeneAdresse + ">");		zEigenerPort = this.verbindungsSocket().getLocalPort();	 			if (this.mitProtokoll()) 			System.out.println("\u00D6ffne Verbindung: - Eigene IP <" + zEigeneAdresse + "> - Partner-IP <" + zPartnerAdresse + "> - Eigener Port: " + zEigenerPort + " Partner-Port: " + zPartnerPort); 		try	 	{			// Den Eingabe- und Ausgabestream holen			hatEingabe = new BufferedReader(new InputStreamReader(hatSocket.getInputStream())); 	 		hatAusgabe = new PrintStream(hatSocket.getOutputStream(), true); 		}    		catch (Exception fehler)	 	{	 		System.err.println("Fehler beim Erzeugen der Streams der Verbindung: " + fehler);	 	}	 		 }	public String toString()	{		return "Verbindung mit Socket: " + hatSocket;	}		/**	Ein Text wurde in den Ausgabestream geschrieben.	@param pNachricht Text, der geschrieben werden soll	*/ 	public void sende(String pNachricht) 	{		try	 	{	 		hatAusgabe.print(pNachricht + "\r\n");	 		if (this.mitProtokoll())		 		System.out.println("Verbindung sendet: " + pNachricht);		 }	 	catch (Exception fehler)	 	{	 		System.err.println("Fehler beim Schreiben in der Verbindung: " + fehler);	 	}	 			 		 	}	 	/**	Ein Text des Eingabestreams wurde geliefert.	*/	public String empfangeneNachricht()	{		String lEingabe = null;		try	 	{			lEingabe = hatEingabe.readLine();	 		if (this.mitProtokoll() && zVerbindungAktiv)		 		System.out.println("Verbindung liest: " + lEingabe);		}	 	catch (Exception fehler)	 	{	 		if (zVerbindungAktiv)	 			System.err.println("Fehler beim Lesen in der Verbindung: " + fehler);	 	}	 		 			 		 	 	return lEingabe;	}		/**	liefert den Socket der Verbindung	*/	protected Socket verbindungsSocket()	{		return hatSocket;	}		/**	gibt an, ob alle Operationen der Verbindung mitprotokolliert werden sollen.	*/	public boolean mitProtokoll()	{		return zMitNachrichten;	}		/**	 Die IP-Nummer des Partners wird geliefert.	*/	public String partnerAdresse()	{		return zPartnerAdresse;	}		/**	 Die eigene IP-Nummer wird geliefert.	*/	public String eigeneAdresse()	{		return zEigeneAdresse;	}		/**	 Der Port des Partners wird geliefert.	*/	public int partnerPort()	{		return zPartnerPort;	}		/**	 Der eigene Port wird geliefert.	*/	public int eigenerPort()	{		return zEigenerPort;	}		/**	 Es wird geliefert, ob tatsaechlich eine Verbindung vorhanden ist.	*/	public boolean vorhanden()	{		return  hatSocket != null;	}		/**	Die Verbindung wurde mit Ein- und Ausgabestreams geschlossen.	*/ 	public void gibFrei() 	{ 		zVerbindungAktiv = false; 			 	try	 	{			// Die Streams und den Socket schliessen		 	if (this.mitProtokoll())		 	{	 			System.out.println("Schlie\u00DFe Verbindung mit Socket: " + hatSocket);	 			System.out.println("");	 		}		//	hatEingabe.close(); hatEingabe = null;		//	hatAusgabe.close(); hatAusgabe = null;		 	hatSocket.close(); hatSocket = null;		 }	 	catch (Exception fehler)	 	{	 		System.err.println("Fehler beim Schlie\u00DFen der Verbindung: " + fehler); 		} 	} 		}